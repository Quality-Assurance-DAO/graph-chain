<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cardano Blockchain Graph Visualization</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        #header {
            background-color: #2d2d2d;
            padding: 15px 20px;
            border-bottom: 2px solid #3d3d3d;
        }
        #header h1 {
            margin: 0;
            font-size: 24px;
            color: #00d4ff;
        }
        #status {
            display: inline-block;
            margin-left: 20px;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
        }
        .status-active {
            background-color: #4caf50;
            color: white;
        }
        .status-paused {
            background-color: #ff9800;
            color: white;
        }
        .status-error {
            background-color: #f44336;
            color: white;
        }
        #graph-container {
            width: 100%;
            height: calc(100vh - 80px);
            background-color: #1a1a1a;
        }
        #info-panel {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 300px;
            background-color: rgba(45, 45, 45, 0.9);
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }
        #browse-panel {
            position: absolute;
            top: 80px;
            left: 20px;
            width: 350px;
            background-color: rgba(45, 45, 45, 0.9);
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            max-height: calc(100vh - 100px);
            display: none;
        }
        #browse-panel.active {
            display: block;
        }
        #browse-panel h3 {
            margin-top: 0;
            color: #00d4ff;
        }
        .search-box {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background-color: #1a1a1a;
            border: 1px solid #3d3d3d;
            border-radius: 3px;
            color: #ffffff;
            font-size: 12px;
        }
        .filter-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        .filter-btn {
            flex: 1;
            padding: 5px;
            background-color: #2d2d2d;
            border: 1px solid #3d3d3d;
            border-radius: 3px;
            color: #ffffff;
            cursor: pointer;
            font-size: 11px;
        }
        .filter-btn.active {
            background-color: #00d4ff;
            color: #1a1a1a;
        }
        .node-list {
            max-height: calc(100vh - 250px);
            overflow-y: auto;
        }
        .node-item {
            padding: 8px;
            margin: 5px 0;
            background-color: #2d2d2d;
            border-left: 3px solid #00d4ff;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .node-item:hover {
            background-color: #3d3d3d;
        }
        .node-item.block {
            border-left-color: #00d4ff;
        }
        .node-item.transaction {
            border-left-color: #ff6b6b;
        }
        .node-item.address {
            border-left-color: #4ecdc4;
        }
        .node-label {
            font-weight: bold;
            color: #ffffff;
            font-size: 12px;
        }
        .node-details {
            font-size: 10px;
            color: #aaaaaa;
            margin-top: 3px;
        }
        .toggle-browse {
            position: absolute;
            top: 80px;
            left: 20px;
            padding: 10px 15px;
            background-color: rgba(45, 45, 45, 0.9);
            border: 1px solid #3d3d3d;
            border-radius: 5px;
            color: #00d4ff;
            cursor: pointer;
            font-size: 12px;
            z-index: 1000;
        }
        .toggle-browse:hover {
            background-color: rgba(45, 45, 45, 1);
        }
        #info-panel h3 {
            margin-top: 0;
            color: #00d4ff;
        }
        .info-item {
            margin: 10px 0;
            padding: 5px;
            border-bottom: 1px solid #3d3d3d;
        }
        .info-label {
            font-weight: bold;
            color: #aaaaaa;
        }
        .info-value {
            color: #ffffff;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>Cardano Blockchain Graph Visualization</h1>
        <span id="status" class="status-active">Loading...</span>
    </div>
    <button class="toggle-browse" onclick="toggleBrowsePanel()">ðŸ“‹ Browse Nodes</button>
    <div id="browse-panel">
        <h3>Browse Captured Data</h3>
        <input type="text" id="search-input" class="search-box" placeholder="Search nodes..." oninput="searchNodes()">
        <div class="filter-buttons">
            <button class="filter-btn active" onclick="filterNodes('')">All</button>
            <button class="filter-btn" onclick="filterNodes('block')">Blocks</button>
            <button class="filter-btn" onclick="filterNodes('transaction')">Txs</button>
            <button class="filter-btn" onclick="filterNodes('address')">Addresses</button>
        </div>
        <div id="node-count-display" style="margin-bottom: 10px; color: #aaaaaa; font-size: 11px;">
            Showing 0 / 0 nodes (Max: 30)
        </div>
        <div id="node-list" class="node-list"></div>
    </div>
    <div id="graph-container"></div>
    <div id="info-panel">
        <h3>Graph Statistics</h3>
        <div class="info-item">
            <span class="info-label">Nodes:</span>
            <span class="info-value" id="node-count">0</span> / 30 (max)
        </div>
        <div class="info-item">
            <span class="info-label">Edges:</span>
            <span class="info-value" id="edge-count">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">Latest Block:</span>
            <span class="info-value" id="latest-block">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">Zoom Level:</span>
            <span class="info-value" id="zoom-level">Block View</span>
        </div>
        <div class="info-item">
            <button onclick="toggleZoomLevel()" style="width: 100%; padding: 5px; background-color: #00d4ff; border: none; border-radius: 3px; color: #1a1a1a; cursor: pointer; font-weight: bold;">
                Switch to Transaction View
            </button>
        </div>
        <div class="info-item">
            <span class="info-label">Last Update:</span>
            <span class="info-value" id="last-update">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">API Status:</span>
            <span class="info-value" id="api-status">-</span>
        </div>
        <div class="info-item" id="rate-limit-warning" style="display: none;">
            <span class="info-label" style="color: #ff9800;">Rate Limited:</span>
            <span class="info-value" style="color: #ff9800;" id="rate-limit-info">-</span>
        </div>
        <div class="info-item" id="error-warning" style="display: none;">
            <span class="info-label" style="color: #f44336;">Error:</span>
            <span class="info-value" style="color: #f44336;" id="error-message">-</span>
        </div>
    </div>

    <script>
        // Initialize network
        let network = null;
        let nodes = new vis.DataSet([]);
        let edges = new vis.DataSet([]);
        
        const container = document.getElementById('graph-container');
        const data = { nodes: nodes, edges: edges };
        
        // Zoom level state
        let currentZoomLevel = 'block'; // 'block' or 'transaction'
        let visibleBlocks = new Set();
        let collapsedBlocks = new Set();
        const MAX_VISIBLE_BLOCKS = 30;
        
        // Color coding functions
        function getNodeColor(node) {
            const type = node.type || 'unknown';
            const activityScore = node.activity_score || 0;
            
            if (type === 'block') {
                // Color blocks by activity: low (blue) -> medium (yellow) -> high (red)
                if (activityScore < 30) {
                    return { background: '#4a90e2', border: '#2e5c8a', highlight: { background: '#6ba3f0', border: '#4a90e2' } };
                } else if (activityScore < 70) {
                    return { background: '#f5a623', border: '#d68910', highlight: { background: '#ffb84d', border: '#f5a623' } };
                } else {
                    return { background: '#e74c3c', border: '#c0392b', highlight: { background: '#ec7063', border: '#e74c3c' } };
                }
            } else if (type === 'transaction') {
                return { background: '#ff6b6b', border: '#cc5555', highlight: { background: '#ff8888', border: '#ff6b6b' } };
            } else if (type === 'address') {
                return { background: '#4ecdc4', border: '#3ba89f', highlight: { background: '#6eddd4', border: '#4ecdc4' } };
            }
            return { background: '#848484', border: '#666666' };
        }
        
        function getNodeSize(node) {
            const type = node.type || 'unknown';
            const activityScore = node.activity_score || 0;
            
            if (type === 'block') {
                // Size based on activity: 25-40 pixels
                return 25 + (activityScore / 100) * 15;
            } else if (type === 'transaction') {
                return 22;
            } else if (type === 'address') {
                return 18;
            }
            return 16;
        }
        
        const options = {
            nodes: {
                shape: 'dot',
                size: 20,
                font: {
                    size: 12,
                    color: '#ffffff',
                    face: 'Arial'
                },
                borderWidth: 2,
                shadow: true,
                chosen: {
                    node: function(values, id, selected, hovering) {
                        if (hovering || selected) {
                            values.size = 30;
                            values.borderWidth = 4;
                        }
                    }
                }
            },
            edges: {
                width: 2,
                color: { color: '#848484' },
                smooth: {
                    type: 'continuous',
                    roundness: 0.5
                },
                arrows: {
                    to: { enabled: true, scaleFactor: 0.8, length: 15 }
                },
                font: {
                    size: 11,
                    color: '#ffffff',
                    align: 'middle',
                    background: 'rgba(0,0,0,0.7)',
                    strokeWidth: 2,
                    strokeColor: '#000000'
                },
                labelHighlightBold: true,
                chosen: {
                    edge: function(values, id, selected, hovering) {
                        if (hovering || selected) {
                            values.width = 4;
                            values.color = { color: '#00d4ff' };
                        }
                    }
                }
            },
            physics: {
                enabled: true,
                stabilization: {
                    iterations: 100
                }
            },
            interaction: {
                hover: true,
                tooltipDelay: 100
            }
        };
        
        network = new vis.Network(container, data, options);
        
        // Node styling based on type (T032 - visual distinction)
        network.on('stabilizationEnd', function() {
            updateNodeStyles();
        });
        
        function updateNodeStyles() {
            nodes.forEach(function(node) {
                const nodeData = node;
                const type = nodeData.type || 'unknown';
                const color = getNodeColor(nodeData);
                const size = getNodeSize(nodeData);
                
                let shape = 'dot';
                if (type === 'block') shape = 'box';
                else if (type === 'transaction') shape = 'diamond';
                else if (type === 'address') shape = 'dot';
                
                // Apply visibility based on zoom level
                let hidden = false;
                if (currentZoomLevel === 'block' && type !== 'block' && type !== 'chain') {
                    // In block view, hide transactions and addresses unless block is expanded
                    const blockId = findBlockForNode(nodeData.id);
                    if (blockId && !visibleBlocks.has(blockId)) {
                        hidden = true;
                    }
                }
                
                nodes.update({
                    id: nodeData.id,
                    color: color,
                    shape: shape,
                    size: size,
                    hidden: hidden,
                    font: {
                        size: type === 'block' ? 14 : 12,
                        color: '#ffffff'
                    }
                });
            });
        }
        
        function findBlockForNode(nodeId) {
            // Find which block a transaction or address belongs to
            const node = nodes.get(nodeId);
            if (!node) return null;
            
            if (node.type === 'block') return nodeId;
            
            // Check edges to find connected block
            const nodeEdges = edges.get({
                filter: function(edge) {
                    return edge.from === nodeId || edge.to === nodeId;
                }
            });
            
            for (let edge of nodeEdges) {
                const otherId = edge.from === nodeId ? edge.to : edge.from;
                const otherNode = nodes.get(otherId);
                if (otherNode && otherNode.type === 'block') {
                    return otherId;
                }
            }
            return null;
        }
        
        function toggleZoomLevel() {
            currentZoomLevel = currentZoomLevel === 'block' ? 'transaction' : 'block';
            document.getElementById('zoom-level').textContent = 
                currentZoomLevel === 'block' ? 'Block View' : 'Transaction View';
            
            const button = event.target;
            button.textContent = currentZoomLevel === 'block' 
                ? 'Switch to Transaction View' 
                : 'Switch to Block View';
            
            // Update visibility
            updateNodeStyles();
            
            // Smooth transition
            network.fit({
                animation: {
                    duration: 500,
                    easingFunction: 'easeInOutQuad'
                }
            });
        }
        
        // Handle zoom events for dynamic expansion
        network.on('zoom', function(params) {
            const scale = params.scale;
            // When zoomed in enough, show transaction details
            if (scale > 1.5 && currentZoomLevel === 'block') {
                // Could auto-expand blocks here
            }
        });
        
        // Double-click to expand/collapse blocks
        network.on('doubleClick', function(params) {
            if (params.nodes.length > 0) {
                const nodeId = params.nodes[0];
                const node = nodes.get(nodeId);
                if (node && node.type === 'block') {
                    if (visibleBlocks.has(nodeId)) {
                        visibleBlocks.delete(nodeId);
                    } else {
                        visibleBlocks.add(nodeId);
                    }
                    updateNodeStyles();
                }
            }
        });
        
        // Node interaction handlers (T031 - highlight connected nodes)
        let highlightedNodes = new Set();
        let highlightedEdges = new Set();
        
        network.on('hoverNode', function(params) {
            highlightConnectedNodes(params.node);
        });
        
        network.on('blurNode', function(params) {
            unhighlightNodes();
        });
        
        network.on('click', function(params) {
            if (params.nodes.length > 0) {
                highlightConnectedNodes(params.nodes[0]);
            } else {
                unhighlightNodes();
            }
        });
        
        function highlightConnectedNodes(nodeId) {
            unhighlightNodes();
            
            // Get all connected nodes
            const connectedNodeIds = new Set();
            const connectedEdgeIds = new Set();
            
            // Get edges connected to this node
            edges.forEach(function(edge) {
                if (edge.from === nodeId || edge.to === nodeId) {
                    connectedEdgeIds.add(edge.id);
                    if (edge.from === nodeId) connectedNodeIds.add(edge.to);
                    if (edge.to === nodeId) connectedNodeIds.add(edge.from);
                }
            });
            
            // Highlight connected nodes and edges
            connectedNodeIds.forEach(function(id) {
                highlightedNodes.add(id);
                nodes.update({ id: id, opacity: 0.3 });
            });
            highlightedEdges = connectedEdgeIds;
            edges.forEach(function(edge) {
                if (connectedEdgeIds.has(edge.id)) {
                    edges.update({ id: edge.id, color: { color: '#00d4ff', highlight: '#00d4ff' } });
                } else {
                    edges.update({ id: edge.id, opacity: 0.1 });
                }
            });
            
            // Keep selected node fully visible
            nodes.update({ id: nodeId, opacity: 1 });
        }
        
        function unhighlightNodes() {
            highlightedNodes.forEach(function(id) {
                nodes.update({ id: id, opacity: 1 });
            });
            highlightedNodes.clear();
            
            edges.forEach(function(edge) {
                edges.update({ id: edge.id, opacity: 1, color: { color: '#848484' } });
            });
            highlightedEdges.clear();
        }
        
        // Load initial graph state
        function loadGraph() {
            fetch('/api/graph')
                .then(response => response.json())
                .then(data => {
                    if (data.nodes && data.edges) {
                        nodes.clear();
                        edges.clear();
                        nodes.add(data.nodes.map(node => ({
                            id: node.id,
                            label: node.label || node.id,
                            type: node.type,
                            title: JSON.stringify(node.data, null, 2),
                            activity_score: node.activity_score || 0,
                            height: node.height,
                            tx_count: node.tx_count || 0,
                            level: node.level || 0
                        })));
                        
                        // Track visible blocks
                        data.nodes.forEach(node => {
                            if (node.type === 'block') {
                                visibleBlocks.add(node.id);
                            }
                        });
                        edges.add(data.edges.map(edge => {
                            // Enhanced edge labeling (T030 - show amounts and types)
                            let edgeLabel = edge.label || '';
                            let edgeTitle = `Type: ${edge.type}`;
                            let edgeWidth = 2;
                            let edgeColor = '#848484';
                            
                            if (edge.type === 'chain') {
                                // Chain edges (block to block) are thicker and more prominent
                                edgeWidth = 4;
                                edgeColor = '#00d4ff';
                                edgeLabel = '';
                                edgeTitle = 'Block Chain';
                            } else if (edge.type === 'tx_output' && edge.weight) {
                                edgeTitle += `\nAmount: ${edge.label || edge.weight}`;
                                edgeWidth = 2;
                            } else if (edge.type === 'tx_input') {
                                edgeTitle += '\nInput connection';
                                edgeWidth = 1.5;
                            } else if (edge.type === 'block_tx') {
                                edgeTitle += '\nBlock contains transaction';
                                edgeWidth = 2;
                            }
                            
                            return {
                                id: edge.from + '-' + edge.to,
                                from: edge.from,
                                to: edge.to,
                                label: edgeLabel,
                                title: edgeTitle,
                                type: edge.type,
                                weight: edge.weight || 1,
                                width: edgeWidth,
                                color: { color: edgeColor, highlight: '#00d4ff' }
                            };
                        }));
                        updateVisibleBlocks();
                        updateNodeStyles();
                        updateStats(data.metadata);
                        
                        // Refresh browse panel if it's open
                        if (document.getElementById('browse-panel').classList.contains('active')) {
                            loadBrowseNodes();
                        }
                        
                        // Auto-fit to show block sequence
                        if (network && currentZoomLevel === 'block') {
                            setTimeout(() => {
                                network.fit({
                                    animation: {
                                        duration: 1000,
                                        easingFunction: 'easeInOutQuad'
                                    }
                                });
                            }, 500);
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading graph:', error);
                    updateStatus('error', 'Error loading graph');
                });
        }
        
        // Update statistics display
        function updateStats(metadata) {
            if (metadata) {
                document.getElementById('node-count').textContent = metadata.node_count || 0;
                document.getElementById('edge-count').textContent = metadata.edge_count || 0;
                document.getElementById('latest-block').textContent = metadata.latest_block_height || '-';
                document.getElementById('last-update').textContent = 
                    metadata.last_update ? new Date(metadata.last_update).toLocaleTimeString() : '-';
            }
        }
        
        // Browse panel functionality
        let currentFilter = '';
        let currentSearch = '';
        
        function toggleBrowsePanel() {
            const panel = document.getElementById('browse-panel');
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                loadBrowseNodes();
            }
        }
        
        function filterNodes(type) {
            currentFilter = type;
            // Update button states
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            loadBrowseNodes();
        }
        
        function searchNodes() {
            currentSearch = document.getElementById('search-input').value;
            loadBrowseNodes();
        }
        
        function loadBrowseNodes() {
            const params = new URLSearchParams();
            if (currentSearch) params.append('q', currentSearch);
            if (currentFilter) params.append('type', currentFilter);
            params.append('limit', 100);
            
            fetch('/api/nodes?' + params.toString())
                .then(response => response.json())
                .then(data => {
                    displayBrowseNodes(data.nodes, data.total);
                })
                .catch(error => {
                    console.error('Error loading nodes:', error);
                    document.getElementById('node-list').innerHTML = '<div style="color: #f44336;">Error loading nodes</div>';
                });
        }
        
        function displayBrowseNodes(nodeList, total) {
            const container = document.getElementById('node-list');
            const countDisplay = document.getElementById('node-count-display');
            
            countDisplay.textContent = `Showing ${nodeList.length} / ${total} nodes (Max: 30)`;
            
            if (nodeList.length === 0) {
                container.innerHTML = '<div style="color: #aaaaaa; padding: 20px; text-align: center;">No nodes found</div>';
                return;
            }
            
            container.innerHTML = nodeList.map(node => {
                const type = node.type || 'unknown';
                const label = node.label || node.id;
                const data = node.data || {};
                
                let details = '';
                if (type === 'block') {
                    details = `Height: ${data.block_height || 'N/A'} | Hash: ${(data.block_hash || '').substring(0, 16)}...`;
                } else if (type === 'transaction') {
                    details = `Hash: ${(data.tx_hash || '').substring(0, 16)}... | Block: ${data.block_height || 'N/A'}`;
                } else if (type === 'address') {
                    details = `Address: ${(data.address || '').substring(0, 20)}... | Tx Count: ${data.transaction_count || 0}`;
                }
                
                return `
                    <div class="node-item ${type}" onclick="focusNode('${node.id}')">
                        <div class="node-label">${label}</div>
                        <div class="node-details">${details}</div>
                    </div>
                `;
            }).join('');
        }
        
        function focusNode(nodeId) {
            // Focus on the node in the graph
            if (network) {
                network.focus(nodeId, {
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
                highlightConnectedNodes(nodeId);
            }
        }
        
        // Update status indicator
        function updateStatus(status, message) {
            const statusEl = document.getElementById('status');
            statusEl.className = 'status-' + status;
            statusEl.textContent = message;
        }
        
        // Connect to SSE stream for real-time updates
        function connectSSE() {
            const eventSource = new EventSource('/api/graph/updates');
            
            eventSource.addEventListener('graph_update', function(event) {
                try {
                    const update = JSON.parse(event.data);
                    handleGraphUpdate(update);
                    // Refresh browse panel if it's open
                    if (document.getElementById('browse-panel').classList.contains('active')) {
                        loadBrowseNodes();
                    }
                } catch (error) {
                    console.error('Error parsing SSE update:', error);
                }
            });
            
            eventSource.onerror = function(error) {
                console.error('SSE error:', error);
                eventSource.close();
                // Retry connection after delay
                setTimeout(connectSSE, 5000);
            };
        }
        
        // Handle graph update events
        function handleGraphUpdate(update) {
            if (update.type === 'node_added' && update.node) {
                const node = update.node;
                nodes.add({
                    id: node.id,
                    label: node.data.label || node.id,
                    type: node.type,
                    title: JSON.stringify(node.data, null, 2)
                });
                updateNodeStyles();
            } else if (update.type === 'edge_added' && update.edge) {
                const edge = update.edge;
                let edgeTitle = `Type: ${edge.type}`;
                if (edge.type === 'tx_output' && edge.weight) {
                    edgeTitle += `\nAmount: ${edge.label || edge.weight}`;
                }
                edges.add({
                    id: edge.from + '-' + edge.to,
                    from: edge.from,
                    to: edge.to,
                    label: edge.label || '',
                    title: edgeTitle,
                    type: edge.type,
                    weight: edge.weight || 1
                });
            }
            
            // Refresh stats periodically
            loadGraph();
        }
        
        // Check system status (T038 - status display UI)
        function checkStatus() {
            fetch('/api/status')
                .then(response => response.json())
                .then(data => {
                    updateStatus(data.status || 'active', data.status || 'Active');
                    
                    // Update API status
                    document.getElementById('api-status').textContent = data.api_status || '-';
                    
                    // Update rate limit warning (T038)
                    const rateLimitWarning = document.getElementById('rate-limit-warning');
                    const rateLimitInfo = document.getElementById('rate-limit-info');
                    if (data.rate_limit_status && data.rate_limit_status.limited) {
                        rateLimitWarning.style.display = 'block';
                        const retryAfter = data.rate_limit_status.retry_after || 'unknown';
                        rateLimitInfo.textContent = `Retry in ${retryAfter}s`;
                    } else {
                        rateLimitWarning.style.display = 'none';
                    }
                    
                    // Update error warning (T038, T040)
                    const errorWarning = document.getElementById('error-warning');
                    const errorMessage = document.getElementById('error-message');
                    if (data.error_message) {
                        errorWarning.style.display = 'block';
                        errorMessage.textContent = data.error_message.substring(0, 50) + '...';
                    } else {
                        errorWarning.style.display = 'none';
                    }
                    
                    // Update last block fetched
                    if (data.last_block_fetched) {
                        document.getElementById('last-update').textContent = 
                            new Date(data.last_block_fetched).toLocaleTimeString();
                    }
                })
                .catch(error => {
                    console.error('Error checking status:', error);
                    updateStatus('error', 'Status check failed');
                });
        }
        
        // Initialize
        loadGraph();
        connectSSE();
        checkStatus();
        setInterval(checkStatus, 10000); // Check status every 10 seconds
    </script>
</body>
</html>


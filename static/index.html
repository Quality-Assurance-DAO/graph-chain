<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cardano Blockchain Graph Visualization</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        /* CSS Variables for Theme System */
        :root {
            /* Dark Theme (default) */
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3d3d3d;
            --bg-panel: rgba(45, 45, 45, 0.9);
            --text-primary: #ffffff;
            --text-secondary: #aaaaaa;
            --text-accent: #00d4ff;
            --border-color: #3d3d3d;
            --shadow-color: rgba(0, 0, 0, 0.5);
        }
        
        [data-theme="light"] {
            /* Light Theme */
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-tertiary: #e0e0e0;
            --bg-panel: rgba(245, 245, 245, 0.95);
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --text-accent: #0066cc;
            --border-color: #cccccc;
            --shadow-color: rgba(0, 0, 0, 0.1);
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        #header {
            background-color: var(--bg-secondary);
            padding: 15px 20px;
            border-bottom: 2px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        #header h1 {
            margin: 0;
            font-size: 24px;
            color: var(--text-accent);
            transition: color 0.3s ease;
        }
        .theme-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 10px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            color: var(--text-primary);
        }
        .theme-toggle:hover {
            background-color: var(--bg-secondary);
        }
        .theme-toggle-icon {
            font-size: 16px;
        }
        #status {
            display: inline-block;
            margin-left: 20px;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
        }
        .status-active {
            background-color: #4caf50;
            color: white;
        }
        .status-paused {
            background-color: #ff9800;
            color: white;
        }
        .status-error {
            background-color: #f44336;
            color: white;
        }
        /* Status colors remain fixed for visibility in both themes */
        #graph-container {
            width: 100%;
            height: calc(100vh - 80px);
            background-color: var(--bg-primary);
            transition: background-color 0.3s ease;
        }
        #info-panel {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 300px;
            background-color: var(--bg-panel);
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 10px var(--shadow-color);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        #flow-path-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--bg-panel);
            padding: 12px 20px;
            border-radius: 5px;
            border: 2px solid var(--text-accent);
            box-shadow: 0 4px 12px var(--shadow-color);
            font-size: 12px;
            color: var(--text-primary);
            z-index: 2000;
            max-width: 500px;
            display: none;
            transition: all 0.3s ease;
        }
        #flow-path-notification.show {
            display: block;
            animation: slideUp 0.3s ease;
        }
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }
        .flow-path-close {
            float: right;
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            margin-left: 10px;
            line-height: 1;
        }
        #browse-panel {
            position: absolute;
            top: 80px;
            left: 20px;
            width: 350px;
            background-color: var(--bg-panel);
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            max-height: calc(100vh - 100px);
            display: none;
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 10px var(--shadow-color);
            transition: background-color 0.3s ease, border-color 0.3s ease;
            z-index: 1001;
            overflow-y: auto;
        }
        #browse-panel.active {
            display: block;
        }
        #browse-panel h3 {
            margin-top: 0;
            color: var(--text-accent);
            transition: color 0.3s ease;
        }
        .search-box {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
            font-size: 12px;
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        .search-box:focus {
            outline: none;
            border-color: var(--text-accent);
        }
        .filter-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        .filter-btn {
            flex: 1;
            padding: 5px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
        }
        .filter-btn:hover {
            background-color: var(--bg-tertiary);
        }
        .filter-btn.active {
            background-color: var(--text-accent);
            color: var(--bg-primary);
            border-color: var(--text-accent);
        }
        .node-list {
            max-height: calc(100vh - 250px);
            overflow-y: auto;
        }
        .node-item {
            padding: 8px;
            margin: 5px 0;
            background-color: var(--bg-secondary);
            border-left: 3px solid var(--text-accent);
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .node-item:hover {
            background-color: var(--bg-tertiary);
        }
        .node-item.block {
            border-left-color: var(--text-accent);
        }
        .node-item.transaction {
            border-left-color: #ff6b6b;
        }
        .node-item.address {
            border-left-color: #4ecdc4;
        }
        .node-label {
            font-weight: bold;
            color: var(--text-primary);
            font-size: 12px;
            transition: color 0.3s ease;
        }
        .node-details {
            font-size: 10px;
            color: var(--text-secondary);
            margin-top: 3px;
            transition: color 0.3s ease;
        }
        .toggle-browse {
            position: absolute;
            top: 80px;
            left: 20px;
            padding: 10px 15px;
            background-color: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-accent);
            cursor: pointer;
            font-size: 12px;
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px var(--shadow-color);
        }
        .toggle-browse:hover {
            background-color: var(--bg-secondary);
        }
        /* Hide toggle button when panel is open */
        body:has(#browse-panel.active) .toggle-browse {
            display: none;
        }
        #info-panel h3 {
            margin-top: 0;
            color: var(--text-accent);
            transition: color 0.3s ease;
        }
        .info-item {
            margin: 10px 0;
            padding: 5px;
            border-bottom: 1px solid var(--border-color);
            transition: border-color 0.3s ease;
        }
        .info-label {
            font-weight: bold;
            color: var(--text-secondary);
            transition: color 0.3s ease;
        }
        .info-value {
            color: var(--text-primary);
            transition: color 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>Cardano Blockchain Graph Visualization</h1>
        <div style="display: flex; align-items: center; gap: 15px;">
            <span id="status" class="status-active">Loading...</span>
            <div class="theme-toggle" onclick="toggleTheme()" title="Toggle Light/Dark Mode">
                <span class="theme-toggle-icon" id="theme-icon">üåô</span>
                <span id="theme-label">Dark</span>
            </div>
        </div>
    </div>
    <button class="toggle-browse" onclick="toggleBrowsePanel()">üìã Browse Nodes</button>
    <div id="browse-panel">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0;">Browse Captured Data</h3>
            <button onclick="toggleBrowsePanel()" style="background: none; border: none; color: var(--text-accent); font-size: 20px; cursor: pointer; padding: 0; width: 24px; height: 24px; line-height: 1; transition: color 0.3s ease;" title="Close">√ó</button>
        </div>
        <input type="text" id="search-input" class="search-box" placeholder="Search nodes..." oninput="searchNodes()">
        <div class="filter-buttons">
            <button class="filter-btn active" onclick="filterNodes('', event)">All</button>
            <button class="filter-btn" onclick="filterNodes('block', event)">Blocks</button>
            <button class="filter-btn" onclick="filterNodes('transaction', event)">Txs</button>
            <button class="filter-btn" onclick="filterNodes('address', event)">Addresses</button>
        </div>
        <div id="node-count-display" style="margin-bottom: 10px; color: var(--text-secondary); font-size: 11px;">
            Showing 0 / 0 nodes (Max: 30)
        </div>
        <div id="node-list" class="node-list"></div>
    </div>
    <div id="graph-container"></div>
    <div id="flow-path-notification">
        <strong style="color: var(--text-accent);">üîç Flow Path Visualization</strong>
        <button class="flow-path-close" onclick="hideFlowPathNotification()" title="Close">√ó</button>
        <div style="margin-top: 5px; line-height: 1.5;">
            <div>Green highlighted edges show value flow paths from input addresses through this transaction to output addresses.</div>
            <div style="margin-top: 5px; font-size: 10px; color: var(--text-secondary);">
                Click anywhere else to clear the visualization.
            </div>
        </div>
    </div>
    <div id="info-panel">
        <h3>Graph Statistics</h3>
        <div class="info-item">
            <span class="info-label">Nodes:</span>
            <span class="info-value" id="node-count">0</span> / 30 (max)
        </div>
        <div class="info-item">
            <span class="info-label">Edges:</span>
            <span class="info-value" id="edge-count">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">Latest Block:</span>
            <span class="info-value" id="latest-block">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">Zoom Level:</span>
            <span class="info-value" id="zoom-level">Block View</span>
        </div>
        <div class="info-item">
            <button id="zoom-toggle-btn" onclick="toggleZoomLevel(event)" style="width: 100%; padding: 5px; background-color: var(--text-accent); border: none; border-radius: 3px; color: var(--bg-primary); cursor: pointer; font-weight: bold; transition: all 0.3s ease;">
                Switch to Transaction View
            </button>
        </div>
        <div class="info-item">
            <span class="info-label">Last Update:</span>
            <span class="info-value" id="last-update">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">API Status:</span>
            <span class="info-value" id="api-status">-</span>
        </div>
        <div class="info-item" id="rate-limit-warning" style="display: none;">
            <span class="info-label" style="color: #ff9800;">Rate Limited:</span>
            <span class="info-value" style="color: #ff9800;" id="rate-limit-info">-</span>
        </div>
        <div class="info-item" id="error-warning" style="display: none;">
            <span class="info-label" style="color: #f44336;">Error:</span>
            <span class="info-value" style="color: #f44336;" id="error-message">-</span>
        </div>
        <div class="info-item">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <h4 style="margin: 0; color: var(--text-accent);">Analytics</h4>
                <button id="analytics-help-toggle" onclick="toggleAnalyticsHelp()" style="background: none; border: none; color: var(--text-accent); cursor: pointer; font-size: 14px; padding: 0; width: 20px; height: 20px;" title="Show/Hide Help">?</button>
            </div>
            
            <div id="analytics-help" style="display: none; margin-bottom: 10px; padding: 8px; background-color: var(--bg-secondary); border-radius: 3px; font-size: 10px; color: var(--text-secondary); line-height: 1.4;">
                <div style="margin-bottom: 8px;">
                    <strong style="color: var(--text-accent);">Color Schemes:</strong>
                    <ul style="margin: 5px 0 0 15px; padding: 0;">
                        <li><strong>Heatmap:</strong> Red (low) ‚Üí Yellow (medium) ‚Üí Green (high activity)</li>
                        <li><strong>Activity:</strong> Blue (low) ‚Üí Purple (medium) ‚Üí Red (high activity)</li>
                        <li><strong>Grayscale:</strong> Black (low) ‚Üí Gray ‚Üí White (high activity)</li>
                    </ul>
                </div>
                <div style="margin-bottom: 8px;">
                    <strong style="color: var(--text-accent);">Metrics:</strong>
                    <ul style="margin: 5px 0 0 15px; padding: 0;">
                        <li><strong>Blocks:</strong> Color shows transaction count</li>
                        <li><strong>Transactions:</strong> Color shows input/output count</li>
                        <li><strong>Addresses:</strong> Color shows UTxO count</li>
                    </ul>
                </div>
                <div style="margin-bottom: 8px;">
                    <strong style="color: var(--text-accent);">Anomalies:</strong>
                    <ul style="margin: 5px 0 0 15px; padding: 0;">
                        <li>Anomalous nodes highlighted with thick red border</li>
                        <li>Requires at least 10 nodes for detection</li>
                        <li>Flags unusually large transactions or high-activity blocks</li>
                    </ul>
                </div>
                <div>
                    <strong style="color: var(--text-accent);">Tips:</strong>
                    <ul style="margin: 5px 0 0 15px; padding: 0;">
                        <li>Click transactions to see flow paths</li>
                        <li>Node labels show degree metrics</li>
                        <li>Recalculate after loading new data</li>
                    </ul>
                </div>
            </div>
            
            <label style="display: block; margin-bottom: 5px; color: var(--text-secondary); font-size: 11px;">
                Color Scheme:
                <span id="color-scheme-help" style="margin-left: 5px; color: var(--text-accent); cursor: help; font-size: 10px;" title="Heatmap: Red‚ÜíYellow‚ÜíGreen shows activity levels. Blocks colored by transaction count, transactions by input/output count, addresses by UTxO count.">‚ÑπÔ∏è</span>
            </label>
            <select id="color-scheme-selector" onchange="changeColorScheme(event)" onfocus="showColorSchemeHelp()" onblur="hideColorSchemeHelp()" style="width: 100%; padding: 5px; background-color: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 3px; color: var(--text-primary); font-size: 11px;">
                <option value="heatmap">Heatmap (Red‚ÜíYellow‚ÜíGreen)</option>
                <option value="activity">Activity (Blue‚ÜíPurple‚ÜíRed)</option>
                <option value="grayscale">Grayscale</option>
            </select>
            <div id="color-scheme-description" style="display: none; margin-top: 3px; padding: 5px; background-color: var(--bg-secondary); border-radius: 3px; font-size: 9px; color: var(--text-secondary); line-height: 1.3;"></div>
            
            <label style="display: flex; align-items: center; margin-top: 8px; margin-bottom: 5px; color: var(--text-secondary); font-size: 11px; cursor: pointer;">
                <input type="checkbox" id="show-anomalies-toggle" checked onchange="toggleAnomalyHighlighting(event)" style="margin-right: 5px; cursor: pointer;">
                <span>Highlight Anomalies</span>
                <span id="anomaly-count" style="margin-left: auto; color: var(--text-accent); font-size: 10px; font-weight: bold;"></span>
            </label>
            
            <button onclick="recalculateAnalytics()" style="width: 100%; margin-top: 5px; padding: 5px; background-color: var(--text-accent); border: none; border-radius: 3px; color: var(--bg-primary); cursor: pointer; font-size: 11px; font-weight: bold;" title="Force recalculation of all analytics metrics. Use after loading new data.">
                Recalculate Analytics
            </button>
            <div id="analytics-loading" style="display: none; margin-top: 5px; color: var(--text-accent); font-size: 10px;">
                <span>‚è≥ Calculating...</span>
            </div>
        </div>
    </div>

    <script>
        // Theme Management
        function initTheme() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            setTheme(savedTheme);
        }
        
        function setTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            
            const icon = document.getElementById('theme-icon');
            const label = document.getElementById('theme-label');
            
            if (icon && label) {
                if (theme === 'light') {
                    icon.textContent = '‚òÄÔ∏è';
                    label.textContent = 'Light';
                } else {
                    icon.textContent = 'üåô';
                    label.textContent = 'Dark';
                }
            }
            
            // Update graph visualization colors
            updateGraphTheme(theme);
        }
        
        // Make toggleTheme globally accessible for onclick handlers
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        }
        
        // Expose to window for global access
        window.toggleTheme = toggleTheme;
        
        function updateGraphTheme(theme) {
            // Check if network and nodes are initialized (handle uninitialized variables)
            if (typeof network === 'undefined' || network === null || 
                typeof nodes === 'undefined' || nodes === null) {
                return;
            }
            
            const isLight = theme === 'light';
            
            // Update node colors based on theme
            nodes.forEach(function(node) {
                const nodeData = node;
                const type = nodeData.type || 'unknown';
                let color = getNodeColor(nodeData, isLight);
                
                nodes.update({
                    id: nodeData.id,
                    color: color
                });
            });
            
            // Update edge colors
            if (edges) {
                edges.forEach(function(edge) {
                    const edgeColor = isLight ? '#666666' : '#848484';
                    edges.update({
                        id: edge.id,
                        color: { color: edgeColor, highlight: '#00d4ff' }
                    });
                });
            }
        }
        
        // Initialize network variables (must be declared before initTheme)
        let network = null;
        let nodes = new vis.DataSet([]);
        let edges = new vis.DataSet([]);
        
        // Analytics state
        let currentColorScheme = 'heatmap';
        let degreeMetrics = {};
        let activityMetrics = {};
        let anomalyMetrics = {}; // Store anomaly data by node_id
        let showAnomalies = true; // Toggle for showing anomaly highlighting
        let isLoadingAnalytics = false;
        let flowPaths = [];
        let highlightedFlowPaths = new Set();
        
        // Initialize theme on page load (after variables are declared)
        initTheme();
        
        const container = document.getElementById('graph-container');
        const data = { nodes: nodes, edges: edges };
        
        // Zoom level state
        let currentZoomLevel = 'block'; // 'block' or 'transaction'
        let visibleBlocks = new Set();
        let collapsedBlocks = new Set();
        const MAX_VISIBLE_BLOCKS = 30;
        
        // Color coding functions
        // Helper function to determine if a color is light (needs dark text)
        function isLightColor(hexColor) {
            // Remove # if present
            hexColor = hexColor.replace('#', '');
            // Convert to RGB
            const r = parseInt(hexColor.substr(0, 2), 16);
            const g = parseInt(hexColor.substr(2, 2), 16);
            const b = parseInt(hexColor.substr(4, 2), 16);
            // Calculate brightness (using relative luminance formula)
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 128;
        }
        
        function getNodeColor(node, isLightTheme = false) {
            const type = node.type || 'unknown';
            const nodeId = node.id;
            
            // Check if this node is an anomaly
            const isAnomaly = showAnomalies && anomalyMetrics[nodeId] && anomalyMetrics[nodeId].is_anomaly;
            const anomalyBorderColor = '#ff0000'; // Red border for anomalies
            const anomalyBorderWidth = isAnomaly ? 5 : 2; // Thicker border for anomalies
            
            // Use color from activity metrics API if available
            if (activityMetrics[nodeId] && activityMetrics[nodeId].color_hex) {
                const colorHex = activityMetrics[nodeId].color_hex;
                const isLight = isLightColor(colorHex);
                
                // Determine border color - use red for anomalies, otherwise theme-based
                let borderColor;
                if (isAnomaly) {
                    borderColor = anomalyBorderColor;
                } else {
                    borderColor = isLightTheme ? (isLight ? '#333333' : '#000000') : (isLight ? '#000000' : '#ffffff');
                }
                
                return {
                    background: colorHex,
                    border: borderColor,
                    borderWidth: anomalyBorderWidth,
                    highlight: {
                        background: adjustBrightness(colorHex, 1.2),
                        border: isAnomaly ? anomalyBorderColor : colorHex
                    },
                    font: {
                        color: isLight ? '#000000' : '#ffffff',
                        strokeWidth: 2,
                        strokeColor: isLight ? '#ffffff' : '#000000'
                    },
                    shadow: isAnomaly ? {
                        enabled: true,
                        color: 'rgba(255, 0, 0, 0.5)',
                        size: 10,
                        x: 0,
                        y: 0
                    } : false
                };
            }
            
            // Fallback to activity score if no API color available
            const activityScore = node.activity_score || 0;
            let colorObj = {};
            
            // Determine border color and width based on anomaly status
            let borderColor;
            let borderWidth = 2;
            if (isAnomaly) {
                borderColor = anomalyBorderColor;
                borderWidth = anomalyBorderWidth;
            }
            
            if (type === 'block') {
                // Color blocks by activity: low (blue) -> medium (yellow) -> high (red)
                if (isLightTheme) {
                    // Light theme colors (more vibrant)
                    if (activityScore < 30) {
                        colorObj = { 
                            background: '#6ba3f0', 
                            border: isAnomaly ? borderColor : '#4a90e2', 
                            borderWidth: borderWidth,
                            highlight: { background: '#8bb5f5', border: isAnomaly ? borderColor : '#6ba3f0' } 
                        };
                    } else if (activityScore < 70) {
                        colorObj = { 
                            background: '#ffb84d', 
                            border: isAnomaly ? borderColor : '#f5a623', 
                            borderWidth: borderWidth,
                            highlight: { background: '#ffc870', border: isAnomaly ? borderColor : '#ffb84d' } 
                        };
                    } else {
                        colorObj = { 
                            background: '#ec7063', 
                            border: isAnomaly ? borderColor : '#e74c3c', 
                            borderWidth: borderWidth,
                            highlight: { background: '#f1948a', border: isAnomaly ? borderColor : '#ec7063' } 
                        };
                    }
                } else {
                    // Dark theme colors (original)
                    if (activityScore < 30) {
                        colorObj = { 
                            background: '#4a90e2', 
                            border: isAnomaly ? borderColor : '#2e5c8a', 
                            borderWidth: borderWidth,
                            highlight: { background: '#6ba3f0', border: isAnomaly ? borderColor : '#4a90e2' } 
                        };
                    } else if (activityScore < 70) {
                        colorObj = { 
                            background: '#f5a623', 
                            border: isAnomaly ? borderColor : '#d68910', 
                            borderWidth: borderWidth,
                            highlight: { background: '#ffb84d', border: isAnomaly ? borderColor : '#f5a623' } 
                        };
                    } else {
                        colorObj = { 
                            background: '#e74c3c', 
                            border: isAnomaly ? borderColor : '#c0392b', 
                            borderWidth: borderWidth,
                            highlight: { background: '#ec7063', border: isAnomaly ? borderColor : '#e74c3c' } 
                        };
                    }
                }
            } else if (type === 'transaction') {
                colorObj = { 
                    background: '#ff6b6b', 
                    border: isAnomaly ? borderColor : '#cc5555', 
                    borderWidth: borderWidth,
                    highlight: { background: '#ff8888', border: isAnomaly ? borderColor : '#ff6b6b' } 
                };
            } else if (type === 'address') {
                colorObj = { 
                    background: '#4ecdc4', 
                    border: isAnomaly ? borderColor : '#3ba89f', 
                    borderWidth: borderWidth,
                    highlight: { background: '#6eddd4', border: isAnomaly ? borderColor : '#4ecdc4' } 
                };
            } else {
                colorObj = { 
                    background: isLightTheme ? '#999999' : '#848484', 
                    border: isAnomaly ? borderColor : (isLightTheme ? '#777777' : '#666666'),
                    borderWidth: borderWidth
                };
            }
            
            // Add font color based on background brightness for better contrast
            const bgColor = colorObj.background || colorObj.highlight?.background || '#848484';
            colorObj.font = {
                color: isLightColor(bgColor) ? '#000000' : '#ffffff',
                strokeWidth: 2,
                strokeColor: isLightColor(bgColor) ? '#ffffff' : '#000000'
            };
            
            // Add shadow/glow effect for anomalies
            if (isAnomaly) {
                colorObj.shadow = {
                    enabled: true,
                    color: 'rgba(255, 0, 0, 0.5)',
                    size: 10,
                    x: 0,
                    y: 0
                };
            }
            
            return colorObj;
        }
        
        function adjustBrightness(hex, factor) {
            // Simple brightness adjustment
            hex = hex.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            const newR = Math.min(255, Math.max(0, Math.round(r * factor)));
            const newG = Math.min(255, Math.max(0, Math.round(g * factor)));
            const newB = Math.min(255, Math.max(0, Math.round(b * factor)));
            
            return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
        }
        
        function getNodeSize(node) {
            const type = node.type || 'unknown';
            const activityScore = node.activity_score || 0;
            
            if (type === 'block') {
                // Size based on activity: 25-40 pixels
                return 25 + (activityScore / 100) * 15;
            } else if (type === 'transaction') {
                return 22;
            } else if (type === 'address') {
                return 18;
            }
            return 16;
        }
        
        const options = {
            nodes: {
                shape: 'dot',
                size: 20,
                font: {
                    size: 12,
                    color: 'var(--text-primary)',
                    face: 'Arial'
                },
                borderWidth: 2,
                shadow: true,
                chosen: {
                    node: function(values, id, selected, hovering) {
                        if (hovering || selected) {
                            values.size = 30;
                            values.borderWidth = 4;
                        }
                    }
                }
            },
            edges: {
                width: 2,
                color: { color: 'var(--text-secondary)' },
                smooth: {
                    type: 'continuous',
                    roundness: 0.5
                },
                arrows: {
                    to: { enabled: true, scaleFactor: 0.8 }
                },
                font: {
                    size: 11,
                    color: 'var(--text-primary)',
                    align: 'middle',
                    background: 'var(--bg-panel)',
                    strokeWidth: 3,
                    strokeColor: 'var(--bg-primary)',
                    vadjust: -2
                },
                labelHighlightBold: true,
                chosen: {
                    edge: function(values, id, selected, hovering) {
                        if (hovering || selected) {
                            values.width = 4;
                            values.color = { color: '#00d4ff' };
                        }
                    }
                }
            },
            physics: {
                enabled: true,
                stabilization: {
                    iterations: 100
                }
            },
            interaction: {
                hover: true,
                tooltipDelay: 100
            }
        };
        
        network = new vis.Network(container, data, options);
        
        // Node styling based on type (T032 - visual distinction)
        network.on('stabilizationEnd', function() {
            updateNodeStyles();
        });
        
        function updateNodeStyles() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
            const isLight = currentTheme === 'light';
            
            nodes.forEach(function(node) {
                const nodeData = node;
                const type = nodeData.type || 'unknown';
                const color = getNodeColor(nodeData, isLight);
                const size = getNodeSize(nodeData);
                
                let shape = 'dot';
                if (type === 'block') shape = 'box';
                else if (type === 'transaction') shape = 'diamond';
                else if (type === 'address') shape = 'dot';
                
                // Apply visibility based on zoom level
                let hidden = false;
                if (currentZoomLevel === 'block' && type !== 'block' && type !== 'chain') {
                    // In block view, hide transactions and addresses unless block is expanded
                    const blockId = findBlockForNode(nodeData.id);
                    if (blockId && !visibleBlocks.has(blockId)) {
                        hidden = true;
                    }
                } else if (currentZoomLevel === 'transaction') {
                    // In transaction view, show all nodes
                    hidden = false;
                }
                
                // Use font color from color object if available, otherwise use theme-based color
                const fontColor = color.font ? color.font.color : (isLight ? '#000000' : '#ffffff');
                const fontStrokeColor = color.font ? color.font.strokeColor : (isLight ? '#ffffff' : '#000000');
                
                // Extract borderWidth and shadow from color object if present
                const borderWidth = color.borderWidth || 2;
                const shadow = color.shadow !== undefined ? color.shadow : false;
                
                nodes.update({
                    id: nodeData.id,
                    color: color,
                    shape: shape,
                    size: size,
                    hidden: hidden,
                    borderWidth: borderWidth,
                    shadow: shadow,
                    font: {
                        size: type === 'block' ? 14 : 12,
                        color: fontColor,
                        strokeWidth: 2,
                        strokeColor: fontStrokeColor
                    }
                });
            });
        }
        
        function findBlockForNode(nodeId) {
            // Find which block a transaction or address belongs to
            const node = nodes.get(nodeId);
            if (!node) return null;
            
            if (node.type === 'block') return nodeId;
            
            // Check edges to find connected block
            const nodeEdges = edges.get({
                filter: function(edge) {
                    return edge.from === nodeId || edge.to === nodeId;
                }
            });
            
            for (let edge of nodeEdges) {
                const otherId = edge.from === nodeId ? edge.to : edge.from;
                const otherNode = nodes.get(otherId);
                if (otherNode && otherNode.type === 'block') {
                    return otherId;
                }
            }
            return null;
        }
        
        // Dynamic collapsing: keep only recent blocks visible
        function updateVisibleBlocks() {
            if (!nodes || nodes.length === 0) return;
            
            try {
                const blockNodes = Array.from(nodes.get({
                    filter: function(node) {
                        return node.type === 'block';
                    }
                }));
                
                if (blockNodes.length === 0) return;
                
                // Sort by height (newest first)
                blockNodes.sort((a, b) => (b.height || 0) - (a.height || 0));
                
                // Keep only the most recent MAX_VISIBLE_BLOCKS
                const recentBlocks = new Set(blockNodes.slice(0, MAX_VISIBLE_BLOCKS).map(n => n.id));
                
                // Update visible blocks set
                visibleBlocks = recentBlocks;
                
                // Collapse older blocks
                blockNodes.forEach(node => {
                    if (!recentBlocks.has(node.id)) {
                        collapsedBlocks.add(node.id);
                    } else {
                        collapsedBlocks.delete(node.id);
                    }
                });
            } catch (error) {
                console.error('Error updating visible blocks:', error);
            }
        }
        
        function toggleZoomLevel(event) {
            currentZoomLevel = currentZoomLevel === 'block' ? 'transaction' : 'block';
            document.getElementById('zoom-level').textContent = 
                currentZoomLevel === 'block' ? 'Block View' : 'Transaction View';
            
            // Update button text
            const button = event && event.target ? event.target : document.getElementById('zoom-toggle-btn');
            if (button) {
                button.textContent = currentZoomLevel === 'block' 
                    ? 'Switch to Transaction View' 
                    : 'Switch to Block View';
            }
            
            // Reload graph with appropriate view
            loadGraph();
            
            // Update visibility after a short delay to ensure nodes are loaded
            setTimeout(() => {
                updateNodeStyles();
                if (network) {
                    network.fit({
                        animation: {
                            duration: 500,
                            easingFunction: 'easeInOutQuad'
                        }
                    });
                }
            }, 100);
        }
        
        // Handle zoom events for dynamic expansion
        network.on('zoom', function(params) {
            const scale = params.scale;
            // When zoomed in enough, show transaction details
            if (scale > 1.5 && currentZoomLevel === 'block') {
                // Could auto-expand blocks here
            }
        });
        
        // Double-click to expand/collapse blocks
        network.on('doubleClick', function(params) {
            if (params.nodes.length > 0) {
                const nodeId = params.nodes[0];
                const node = nodes.get(nodeId);
                if (node && node.type === 'block') {
                    if (visibleBlocks.has(nodeId)) {
                        visibleBlocks.delete(nodeId);
                    } else {
                        visibleBlocks.add(nodeId);
                    }
                    updateNodeStyles();
                }
            }
        });
        
        // Node interaction handlers (T031 - highlight connected nodes)
        let highlightedNodes = new Set();
        let highlightedEdges = new Set();
        
        network.on('hoverNode', function(params) {
            highlightConnectedNodes(params.node);
        });
        
        network.on('blurNode', function(params) {
            unhighlightNodes();
        });
        
        network.on('click', function(params) {
            if (params.nodes.length > 0) {
                const nodeId = params.nodes[0];
                const node = nodes.get(nodeId);
                
                // If clicking a transaction, show flow paths
                if (node && node.type === 'transaction') {
                    showFlowPaths(nodeId);
                }
                
                highlightConnectedNodes(nodeId);
            } else {
                unhighlightNodes();
                clearFlowPaths();
            }
        });
        
        function highlightConnectedNodes(nodeId) {
            unhighlightNodes();
            
            // Get all connected nodes
            const connectedNodeIds = new Set();
            const connectedEdgeIds = new Set();
            
            // Get edges connected to this node
            edges.forEach(function(edge) {
                if (edge.from === nodeId || edge.to === nodeId) {
                    connectedEdgeIds.add(edge.id);
                    if (edge.from === nodeId) connectedNodeIds.add(edge.to);
                    if (edge.to === nodeId) connectedNodeIds.add(edge.from);
                }
            });
            
            // Highlight connected nodes and edges
            connectedNodeIds.forEach(function(id) {
                highlightedNodes.add(id);
                nodes.update({ id: id, opacity: 0.3 });
            });
            highlightedEdges = connectedEdgeIds;
            edges.forEach(function(edge) {
                if (connectedEdgeIds.has(edge.id)) {
                    edges.update({ id: edge.id, color: { color: '#00d4ff', highlight: '#00d4ff' } });
                } else {
                    edges.update({ id: edge.id, opacity: 0.1 });
                }
            });
            
            // Keep selected node fully visible
            nodes.update({ id: nodeId, opacity: 1 });
        }
        
        function unhighlightNodes() {
            highlightedNodes.forEach(function(id) {
                nodes.update({ id: id, opacity: 1 });
            });
            highlightedNodes.clear();
            
            edges.forEach(function(edge) {
                edges.update({ id: edge.id, opacity: 1, color: { color: '#848484' } });
            });
            highlightedEdges.clear();
        }
        
        // Load initial graph state
        function loadGraph() {
            const maxBlocks = currentZoomLevel === 'block' ? MAX_VISIBLE_BLOCKS : null;
            const url = maxBlocks ? `/api/graph?max_blocks=${maxBlocks}` : '/api/graph';
            
            return fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (!data) {
                        console.error('No data returned from API');
                        updateStatus('error', 'No data returned');
                        return;
                    }
                    console.log('Graph data loaded:', { 
                        nodes: data.nodes?.length || 0, 
                        edges: data.edges?.length || 0,
                        zoomLevel: currentZoomLevel,
                        nodeTypes: data.nodes?.map(n => n.type) || []
                    });
                    if (data.nodes && data.edges) {
                        nodes.clear();
                        edges.clear();
                        
                        // Filter nodes and edges based on zoom level
                        let nodesToAdd = data.nodes;
                        let edgesToAdd = data.edges;
                        
                        if (currentZoomLevel === 'block') {
                            // In block view, show only blocks and chain edges
                            nodesToAdd = data.nodes.filter(node => node.type === 'block');
                            edgesToAdd = data.edges.filter(edge => edge.type === 'chain');
                            console.log('Block view filter:', { 
                                blocks: nodesToAdd.length, 
                                chainEdges: edgesToAdd.length,
                                totalEdges: data.edges.length,
                                edgeTypes: data.edges.map(e => e.type)
                            });
                        } else {
                            // Transaction view: show all nodes and edges
                            console.log('Transaction view:', { 
                                nodes: nodesToAdd.length, 
                                edges: edgesToAdd.length 
                            });
                        }
                        
                        nodes.add(nodesToAdd.map(node => {
                            const nodeId = node.id;
                            const nodeType = node.type;
                            
                            // Build label with degree metrics
                            let label = node.label || node.id;
                            let tooltip = JSON.stringify(node.data, null, 2);
                            
                            // Add degree metrics to label/tooltip
                            if (degreeMetrics[nodeId]) {
                                const metrics = degreeMetrics[nodeId];
                                if (nodeType === 'block') {
                                    label = `${label}\n(${metrics.type_degree} txs)`;
                                    tooltip += `\n\nüìä Analytics Metrics:\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                                        `Transaction Count: ${metrics.type_degree}\n` +
                                        `  ‚Üí Number of transactions in this block\n` +
                                        `Total Connections: ${metrics.total_degree}\n` +
                                        `  ‚Üí Total edges connected to this block`;
                                } else if (nodeType === 'transaction') {
                                    const inputCount = metrics.in_degree || 0;
                                    const outputCount = metrics.out_degree || 0;
                                    label = `${label}\n(${inputCount} in, ${outputCount} out)`;
                                    tooltip += `\n\nüìä Analytics Metrics:\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                                        `Input Count: ${inputCount}\n` +
                                        `  ‚Üí Number of input addresses\n` +
                                        `Output Count: ${outputCount}\n` +
                                        `  ‚Üí Number of output addresses\n` +
                                        `Total Connections: ${metrics.total_degree}\n` +
                                        `  ‚Üí Total edges (inputs + outputs)`;
                                } else if (nodeType === 'address') {
                                    tooltip += `\n\nüìä Analytics Metrics:\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                                        `UTxO Count: ${metrics.type_degree}\n` +
                                        `  ‚Üí Number of unspent transaction outputs\n` +
                                        `Total Connections: ${metrics.total_degree}\n` +
                                        `  ‚Üí Total edges connected to this address`;
                                }
                            }
                            
                            // Add activity explanation if available
                            if (activityMetrics[nodeId]) {
                                const activity = activityMetrics[nodeId];
                                tooltip += `\n\nüé® Activity Level:\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                                    `Activity Score: ${activity.normalized_value.toFixed(1)}/100\n` +
                                    `  ‚Üí Normalized activity level (0=low, 100=high)\n` +
                                    `Raw Value: ${activity.raw_value}\n` +
                                    `Color: ${activity.color_hex}\n` +
                                    `  ‚Üí Node color reflects activity level`;
                            }
                            
                            // Add anomaly information if available
                            if (anomalyMetrics[nodeId] && anomalyMetrics[nodeId].is_anomaly) {
                                const anomaly = anomalyMetrics[nodeId];
                                tooltip += `\n\n‚ö†Ô∏è Anomaly Detected:\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                                    `Anomaly Type: ${anomaly.anomaly_type || 'Unknown'}\n` +
                                    `Anomaly Score: ${anomaly.anomaly_score.toFixed(1)}/100\n` +
                                    `  ‚Üí Higher score indicates more unusual pattern\n` +
                                    `This node has been flagged as unusual compared to others`;
                            }
                            
                            return {
                                id: nodeId,
                                label: label,
                                type: nodeType,
                                title: tooltip,
                            activity_score: node.activity_score || 0,
                            height: node.height,
                            tx_count: node.tx_count || 0,
                            level: node.level || 0
                            };
                        }));
                        
                        // Track visible blocks
                        nodesToAdd.forEach(node => {
                            if (node.type === 'block') {
                                visibleBlocks.add(node.id);
                            }
                        });
                        
                        // Get current theme for edge colors
                        const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
                        const isLight = currentTheme === 'light';
                        const defaultEdgeColor = isLight ? '#666666' : '#848484';
                        
                        const edgesToAddFormatted = edgesToAdd.map(edge => {
                            // Enhanced edge labeling (T030 - show amounts and types)
                            let edgeLabel = edge.label || '';
                            let edgeTitle = `Type: ${edge.type}`;
                            let edgeWidth = 2;
                            let edgeColor = defaultEdgeColor;
                            
                            if (edge.type === 'chain') {
                                // Chain edges (block to block) are thicker and more prominent
                                edgeWidth = 4;
                                edgeColor = '#00d4ff'; // Keep accent color for chain edges
                                edgeLabel = '';
                                edgeTitle = 'Block Chain';
                            } else if (edge.type === 'tx_output' && edge.weight) {
                                edgeTitle += `\nAmount: ${edge.label || edge.weight}`;
                                edgeWidth = 2;
                                // Show amount in label for transaction view
                                if (currentZoomLevel === 'transaction') {
                                    edgeLabel = edge.label || `${edge.weight} lovelace`;
                                }
                            } else if (edge.type === 'tx_input') {
                                edgeTitle += '\nInput connection';
                                edgeWidth = 1.5;
                            } else if (edge.type === 'block_tx') {
                                edgeTitle += '\nBlock contains transaction';
                                edgeWidth = 2;
                            }
                            
                            return {
                                id: edge.from + '-' + edge.to,
                                from: edge.from,
                                to: edge.to,
                                label: edgeLabel,
                                title: edgeTitle,
                                type: edge.type,
                                weight: edge.weight || 1,
                                width: edgeWidth,
                                color: { color: edgeColor, highlight: '#00d4ff' },
                                hidden: false,  // Ensure edges are visible
                                opacity: 1
                            };
                        });
                        
                        console.log('Adding edges:', edgesToAddFormatted.length);
                        edges.add(edgesToAddFormatted);
                        
                        // Log warning if no edges in block view with multiple blocks
                        if (currentZoomLevel === 'block' && nodesToAdd.length > 1 && edgesToAddFormatted.length === 0) {
                            console.warn('Block view: Multiple blocks but no chain edges found. Edges may not be loaded yet.');
                        }
                        
                        // Log info if single block with no edges
                        if (currentZoomLevel === 'block' && nodesToAdd.length === 1 && edgesToAddFormatted.length === 0) {
                            console.info('Single block loaded. Chain edges will appear when more blocks are added. Switch to Transaction View to see transactions.');
                        }
                        
                        updateVisibleBlocks();
                        
                        // Update node styles first (without analytics)
                        updateNodeStyles();
                        updateStats(data.metadata);
                        
                        // Update graph theme after loading (reuse currentTheme from above)
                        updateGraphTheme(currentTheme);
                        
                        // Update status to active after successful load
                        updateStatus('active', 'Active');
                        
                        // Load analytics data asynchronously (non-blocking)
                        // This will update colors and labels when ready
                        loadAnalyticsData().then(() => {
                            // Update styles again with analytics data
                            updateNodeStyles();
                        }).catch(err => {
                            console.warn('Analytics loading failed, continuing without analytics:', err);
                        });
                        
                        // Return promise for chaining
                        return Promise.resolve();
                        
                        // Refresh browse panel if it's open
                        if (document.getElementById('browse-panel').classList.contains('active')) {
                            loadBrowseNodes();
                        }
                        
                        // Auto-fit to show block sequence
                        if (network && currentZoomLevel === 'block') {
                            setTimeout(() => {
                                network.fit({
                                    animation: {
                                        duration: 1000,
                                        easingFunction: 'easeInOutQuad'
                                    }
                                });
                            }, 500);
                        }
                    } else {
                        console.error('Invalid graph data structure. Expected nodes and edges:', data);
                        updateStatus('error', 'Invalid data structure');
                    }
                    return data;
                })
                .catch(error => {
                    console.error('Error loading graph:', error);
                    updateStatus('error', 'Error loading graph: ' + error.message);
                    throw error;
                });
        }
        
        // Update statistics display
        function updateStats(metadata) {
            if (metadata) {
                document.getElementById('node-count').textContent = metadata.node_count || 0;
                document.getElementById('edge-count').textContent = metadata.edge_count || 0;
                document.getElementById('latest-block').textContent = metadata.latest_block_height || '-';
                document.getElementById('last-update').textContent = 
                    metadata.last_update ? new Date(metadata.last_update).toLocaleTimeString() : '-';
            }
        }
        
        // Browse panel functionality
        let currentFilter = '';
        let currentSearch = '';
        
        function toggleBrowsePanel() {
            const panel = document.getElementById('browse-panel');
            const toggleButton = document.querySelector('.toggle-browse');
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                loadBrowseNodes();
                // Hide toggle button when panel is open
                if (toggleButton) {
                    toggleButton.style.display = 'none';
                }
            } else {
                // Show toggle button when panel is closed
                if (toggleButton) {
                    toggleButton.style.display = 'block';
                }
            }
        }
        
        function filterNodes(type, event) {
            currentFilter = type;
            
            // Update button states - remove active from all
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Add active to the clicked button
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // Fallback: find button by matching the type
                const buttons = document.querySelectorAll('.filter-btn');
                buttons.forEach(btn => {
                    const btnText = btn.textContent.trim().toLowerCase();
                    if ((type === '' && btnText === 'all') ||
                        (type === 'block' && btnText === 'blocks') ||
                        (type === 'transaction' && btnText === 'txs') ||
                        (type === 'address' && btnText === 'addresses')) {
                        btn.classList.add('active');
                    }
                });
            }
            
            loadBrowseNodes();
        }
        
        function searchNodes() {
            currentSearch = document.getElementById('search-input').value;
            loadBrowseNodes();
        }
        
        function loadBrowseNodes() {
            const params = new URLSearchParams();
            if (currentSearch) params.append('q', currentSearch);
            if (currentFilter) params.append('type', currentFilter);
            params.append('limit', 100);
            
            fetch('/api/nodes?' + params.toString())
                .then(response => response.json())
                .then(data => {
                    displayBrowseNodes(data.nodes, data.total);
                })
                .catch(error => {
                    console.error('Error loading nodes:', error);
                    document.getElementById('node-list').innerHTML = '<div style="color: #f44336;">Error loading nodes</div>';
                    // Error color stays red for visibility
                });
        }
        
        function displayBrowseNodes(nodeList, total) {
            const container = document.getElementById('node-list');
            const countDisplay = document.getElementById('node-count-display');
            
            countDisplay.textContent = `Showing ${nodeList.length} / ${total} nodes (Max: 30)`;
            
            if (nodeList.length === 0) {
                container.innerHTML = '<div style="color: var(--text-secondary); padding: 20px; text-align: center;">No nodes found</div>';
                return;
            }
            
            container.innerHTML = nodeList.map(node => {
                const type = node.type || 'unknown';
                const label = node.label || node.id;
                const data = node.data || {};
                
                let details = '';
                if (type === 'block') {
                    details = `Height: ${data.block_height || 'N/A'} | Hash: ${(data.block_hash || '').substring(0, 16)}...`;
                } else if (type === 'transaction') {
                    details = `Hash: ${(data.tx_hash || '').substring(0, 16)}... | Block: ${data.block_height || 'N/A'}`;
                } else if (type === 'address') {
                    details = `Address: ${(data.address || '').substring(0, 20)}... | Tx Count: ${data.transaction_count || 0}`;
                }
                
                return `
                    <div class="node-item ${type}" onclick="focusNode('${node.id}')">
                        <div class="node-label">${label}</div>
                        <div class="node-details">${details}</div>
                    </div>
                `;
            }).join('');
        }
        
        function focusNode(nodeId) {
            // Check if node exists in current view
            const node = nodes.get(nodeId);
            
            // If node doesn't exist, we might need to switch views or reload
            if (!node) {
                // Check what type of node this is
                // Try to get node info from the API to determine type
                fetch(`/api/nodes/${nodeId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.node) {
                            const nodeType = data.node.type;
                            
                            // If it's a transaction or address and we're in block view, switch to transaction view
                            if ((nodeType === 'transaction' || nodeType === 'address') && currentZoomLevel === 'block') {
                                // Switch to transaction view
                                console.log(`Switching to transaction view to show ${nodeType}: ${nodeId}`);
                                
                                // Show notification
                                updateStatus('active', `Switching to Transaction View to show ${nodeType}...`);
                                
                                currentZoomLevel = 'transaction';
                                document.getElementById('zoom-level').textContent = 'Transaction View';
                                const button = document.getElementById('zoom-toggle-btn');
                                if (button) {
                                    button.textContent = 'Switch to Block View';
                                }
                                
                                // Reload graph in transaction view
                                loadGraph().then(() => {
                                    // After reload, focus on the node
                                    setTimeout(() => {
                                        focusNodeAfterLoad(nodeId);
                                        updateStatus('active', 'Active');
                                    }, 500);
                                }).catch(err => {
                                    console.error('Error loading graph:', err);
                                    updateStatus('error', 'Error loading graph');
                                });
                            } else {
                                // Node might not be loaded yet, try reloading graph
                                loadGraph().then(() => {
                                    setTimeout(() => {
                                        focusNodeAfterLoad(nodeId);
                                    }, 500);
                                }).catch(err => {
                                    console.error('Error loading graph:', err);
                                });
                            }
                        } else {
                            console.warn(`Node ${nodeId} not found in graph`);
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching node info:', error);
                        // Try reloading graph anyway
                        loadGraph().then(() => {
                            setTimeout(() => {
                                focusNodeAfterLoad(nodeId);
                            }, 500);
                        });
                    });
                return;
            }
            
            // Node exists, focus on it
            focusNodeAfterLoad(nodeId);
        }
        
        function focusNodeAfterLoad(nodeId) {
            const node = nodes.get(nodeId);
            if (!node) {
                console.warn(`Node ${nodeId} still not found after reload`);
                return;
            }
            
            // Make sure node is visible
            nodes.update({
                id: nodeId,
                hidden: false
            });
            
            // Focus on the node
            if (network) {
                network.focus(nodeId, {
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    },
                    scale: 1.5  // Zoom in a bit
                });
                
                // Highlight connected nodes and edges
                highlightConnectedNodes(nodeId);
                
                // Ensure connected edges are visible
                const connectedEdges = edges.get({
                    filter: function(edge) {
                        return edge.from === nodeId || edge.to === nodeId;
                    }
                });
                
                connectedEdges.forEach(edge => {
                    edges.update({
                        id: edge.id,
                        hidden: false,
                        opacity: 1
                    });
                });
            }
        }
        
        // Update status indicator
        function updateStatus(status, message) {
            const statusEl = document.getElementById('status');
            statusEl.className = 'status-' + status;
            statusEl.textContent = message;
        }
        
        // Connect to SSE stream for real-time updates
        function connectSSE() {
            const eventSource = new EventSource('/api/graph/updates');
            
            eventSource.addEventListener('graph_update', function(event) {
                try {
                    const update = JSON.parse(event.data);
                    handleGraphUpdate(update);
                    // Refresh browse panel if it's open
                    if (document.getElementById('browse-panel').classList.contains('active')) {
                        loadBrowseNodes();
                    }
                } catch (error) {
                    console.error('Error parsing SSE update:', error);
                }
            });
            
            eventSource.onerror = function(error) {
                console.error('SSE error:', error);
                eventSource.close();
                // Retry connection after delay
                setTimeout(connectSSE, 5000);
            };
        }
        
        // Handle graph update events
        function handleGraphUpdate(update) {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
            const isLight = currentTheme === 'light';
            
            if (update.type === 'node_added' && update.node) {
                const node = update.node;
                
                // Check if node already exists
                if (nodes.get(node.id)) {
                    // Update existing node instead of adding
                    const nodeData = {
                        id: node.id,
                        label: node.label || node.data.label || node.id,
                        type: node.type,
                        title: JSON.stringify(node.data, null, 2),
                        activity_score: node.activity_score || 0,
                        height: node.height,
                        tx_count: node.tx_count || 0
                    };
                    nodes.update(nodeData);
                    return;
                }
                
                const nodeData = {
                    id: node.id,
                    label: node.label || node.data.label || node.id,
                    type: node.type,
                    title: JSON.stringify(node.data, null, 2),
                    activity_score: node.activity_score || 0,
                    height: node.height,
                    tx_count: node.tx_count || 0
                };
                
                // Animate new node appearance
                nodes.add({
                    ...nodeData,
                    opacity: 0,
                    size: 0
                });
                
                // Animate to full visibility
                setTimeout(() => {
                    nodes.update({
                        id: node.id,
                        opacity: 1,
                        size: getNodeSize(nodeData),
                        color: getNodeColor(nodeData, isLight)
                    });
                }, 50);
                
                // If it's a block, add to visible set
                if (node.type === 'block') {
                    visibleBlocks.add(node.id);
                }
                
                updateNodeStyles();
                
                // Animate camera to new block if it's a block node
                if (node.type === 'block' && network) {
                    setTimeout(() => {
                        network.focus(node.id, {
                            animation: {
                                duration: 800,
                                easingFunction: 'easeInOutQuad'
                            },
                            scale: 1.2
                        });
                    }, 200);
                }
            } else if (update.type === 'edge_added' && update.edge) {
                const edge = update.edge;
                const edgeId = edge.from + '-' + edge.to;
                
                // Check if edge already exists
                if (edges.get(edgeId)) {
                    // Update existing edge instead of adding
                    let edgeTitle = `Type: ${edge.type}`;
                    if (edge.type === 'tx_output' && edge.weight) {
                        edgeTitle += `\nAmount: ${edge.label || edge.weight}`;
                    }
                    const edgeColor = isLight ? '#666666' : '#848484';
                    edges.update({
                        id: edgeId,
                        from: edge.from,
                        to: edge.to,
                        label: edge.label || '',
                        title: edgeTitle,
                        type: edge.type,
                        weight: edge.weight || 1,
                        color: { color: edgeColor, highlight: '#00d4ff' }
                    });
                    return;
                }
                
                let edgeTitle = `Type: ${edge.type}`;
                if (edge.type === 'tx_output' && edge.weight) {
                    edgeTitle += `\nAmount: ${edge.label || edge.weight}`;
                }
                
                const edgeColor = isLight ? '#666666' : '#848484';
                const edgeData = {
                    id: edgeId,
                    from: edge.from,
                    to: edge.to,
                    label: edge.label || '',
                    title: edgeTitle,
                    type: edge.type,
                    weight: edge.weight || 1,
                    opacity: 0,
                    width: 0,
                    color: { color: edgeColor, highlight: '#00d4ff' }
                };
                
                edges.add(edgeData);
                
                // Animate edge appearance
                setTimeout(() => {
                    edges.update({
                        id: edgeData.id,
                        opacity: 1,
                        width: edge.type === 'chain' ? 3 : 2
                    });
                }, 100);
            }
            
            // Refresh graph after updates (but debounce to avoid too frequent reloads)
            if (!window.graphReloadPending) {
                window.graphReloadPending = true;
                setTimeout(() => {
            loadGraph();
                    window.graphReloadPending = false;
                }, 1000); // Debounce: wait 1 second after last update
            }
        }
        
        // Check system status (T038 - status display UI)
        function checkStatus() {
            fetch('/api/status')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Update status with proper capitalization
                    const status = data.status || 'active';
                    const statusMessage = status.charAt(0).toUpperCase() + status.slice(1);
                    updateStatus(status, statusMessage);
                    
                    // Update API status
                    document.getElementById('api-status').textContent = data.api_status || '-';
                    
                    // Update rate limit warning (T038)
                    const rateLimitWarning = document.getElementById('rate-limit-warning');
                    const rateLimitInfo = document.getElementById('rate-limit-info');
                    if (data.rate_limit_status && data.rate_limit_status.limited) {
                        rateLimitWarning.style.display = 'block';
                        const retryAfter = data.rate_limit_status.retry_after || 'unknown';
                        rateLimitInfo.textContent = `Retry in ${retryAfter}s`;
                    } else {
                        rateLimitWarning.style.display = 'none';
                    }
                    
                    // Update error warning (T038, T040)
                    const errorWarning = document.getElementById('error-warning');
                    const errorMessage = document.getElementById('error-message');
                    if (data.error_message) {
                        errorWarning.style.display = 'block';
                        errorMessage.textContent = data.error_message.substring(0, 50) + '...';
                    } else {
                        errorWarning.style.display = 'none';
                    }
                    
                    // Update last block fetched
                    if (data.last_block_fetched) {
                        document.getElementById('last-update').textContent = 
                            new Date(data.last_block_fetched).toLocaleTimeString();
                    }
                })
                .catch(error => {
                    console.error('Error checking status:', error);
                    updateStatus('error', 'Status check failed');
                });
        }
        
        // Analytics functions
        function loadAnalyticsData() {
            if (isLoadingAnalytics) {
                return Promise.resolve();
            }
            isLoadingAnalytics = true;
            showAnalyticsLoading(true);
            
            // Load degree metrics
            return fetch('/api/analytics/degrees')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Analytics API error: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Store degree metrics by node_id
                    degreeMetrics = {};
                    if (data.metrics) {
                        data.metrics.forEach(metric => {
                            degreeMetrics[metric.node_id] = metric;
                        });
                    }
                    
                    // Load activity metrics with current color scheme
                    return fetch(`/api/analytics/activity?color_scheme=${currentColorScheme}`);
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Activity API error: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Store activity metrics by node_id
                    activityMetrics = {};
                    if (data.metrics) {
                        data.metrics.forEach(metric => {
                            activityMetrics[metric.node_id] = metric;
                        });
                    }
                    
                    // Load anomaly metrics (non-blocking - may fail if insufficient data)
                    return fetch('/api/analytics/anomalies?method=percentile')
                        .then(response => {
                            if (response.ok) {
                                return response.json();
                            } else if (response.status === 400) {
                                // Insufficient data - this is OK, just return empty
                                return { anomalies: [] };
                            } else {
                                throw new Error(`Anomaly API error: ${response.status}`);
                            }
                        })
                        .then(data => {
                            // Store anomaly metrics by node_id
                            anomalyMetrics = {};
                            if (data.anomalies) {
                                data.anomalies.forEach(anomaly => {
                                    if (anomaly.is_anomaly) {
                                        anomalyMetrics[anomaly.node_id] = anomaly;
                                    }
                                });
                            }
                            
                            // Update anomaly count display
                            updateAnomalyCount();
                            
                            return Promise.resolve();
                        })
                        .catch(error => {
                            // Anomaly detection failed (likely insufficient data) - this is OK
                            console.log('Anomaly detection skipped:', error.message);
                            anomalyMetrics = {};
                            updateAnomalyCount();
                            return Promise.resolve();
                        });
                })
                .then(() => {
                    showAnalyticsLoading(false);
                    isLoadingAnalytics = false;
                })
                .catch(error => {
                    console.error('Error loading analytics:', error);
                    showAnalyticsLoading(false);
                    isLoadingAnalytics = false;
                    // Re-throw to allow caller to handle
                    throw error;
                });
        }
        
        function changeColorScheme(event) {
            const scheme = event.target.value;
            currentColorScheme = scheme;
            
            // Update help description
            showColorSchemeHelp();
            
            // Reload activity metrics with new scheme
            fetch(`/api/analytics/activity?color_scheme=${scheme}`)
                .then(response => response.json())
                .then(data => {
                    activityMetrics = {};
                    if (data.metrics) {
                        data.metrics.forEach(metric => {
                            activityMetrics[metric.node_id] = metric;
                        });
                    }
                    updateNodeStyles();
                })
                .catch(error => {
                    console.error('Error changing color scheme:', error);
                });
        }
        
        function recalculateAnalytics() {
            showAnalyticsLoading(true);
            
            fetch('/api/analytics/recalculate', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    // Wait a bit for recalculation, then reload
                    setTimeout(() => {
                        loadAnalyticsData().then(() => {
                            // Update node styles after reloading analytics
                            updateNodeStyles();
                        });
                    }, 500);
                })
                .catch(error => {
                    console.error('Error recalculating analytics:', error);
                    showAnalyticsLoading(false);
                });
        }
        
        function toggleAnomalyHighlighting(event) {
            showAnomalies = event.target.checked;
            updateNodeStyles();
        }
        
        function updateAnomalyCount() {
            const countEl = document.getElementById('anomaly-count');
            if (countEl) {
                const count = Object.keys(anomalyMetrics).length;
                if (count > 0) {
                    countEl.textContent = `(${count})`;
                    countEl.style.display = 'inline';
                } else {
                    countEl.textContent = '';
                    countEl.style.display = 'none';
                }
            }
        }
        
        function showAnalyticsLoading(show) {
            const loadingEl = document.getElementById('analytics-loading');
            if (loadingEl) {
                loadingEl.style.display = show ? 'block' : 'none';
            }
        }
        
        function showFlowPaths(transactionId) {
            fetch(`/api/analytics/flow?transaction_id=${transactionId}&max_depth=5&max_blocks=5`)
                .then(response => response.json())
                .then(data => {
                    flowPaths = data.paths || [];
                    highlightFlowPaths();
                    
                    // Show notification explaining what they're seeing
                    if (flowPaths.length > 0) {
                        showFlowPathNotification(flowPaths.length);
                    }
                })
                .catch(error => {
                    console.error('Error loading flow paths:', error);
                });
        }
        
        function showFlowPathNotification(pathCount) {
            const notification = document.getElementById('flow-path-notification');
            if (notification) {
                // Update content with path count
                const content = notification.querySelector('div > div');
                if (content) {
                    content.innerHTML = `Green highlighted edges show value flow paths from input addresses through this transaction to output addresses. <strong>Found ${pathCount} path${pathCount !== 1 ? 's' : ''}.</strong>`;
                }
                notification.classList.add('show');
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    hideFlowPathNotification();
                }, 10000);
            }
        }
        
        function hideFlowPathNotification() {
            const notification = document.getElementById('flow-path-notification');
            if (notification) {
                notification.classList.remove('show');
            }
        }
        
        window.hideFlowPathNotification = hideFlowPathNotification;
        
        function highlightFlowPaths() {
            // Clear previous highlights
            clearFlowPaths();
            
            // Highlight edges in flow paths
            flowPaths.forEach(path => {
                path.path_edges.forEach(edge => {
                    const edgeId = edge.from + '-' + edge.to;
                    const visEdge = edges.get(edgeId);
                    
                    if (visEdge) {
                        highlightedFlowPaths.add(edgeId);
                        edges.update({
                            id: edgeId,
                            color: { color: '#00ff00', highlight: '#00ff00' },
                            width: 4,
                            dashes: false
                        });
                    }
                });
                
                // Highlight nodes in path
                path.path_nodes.forEach(nodeId => {
                    const node = nodes.get(nodeId);
                    if (node) {
                        nodes.update({
                            id: nodeId,
                            size: (node.size || 20) * 1.3
                        });
                    }
                });
            });
        }
        
        function clearFlowPaths() {
            // Restore edge styles
            highlightedFlowPaths.forEach(edgeId => {
                const edge = edges.get(edgeId);
                if (edge) {
                    const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
                    const isLight = currentTheme === 'light';
                    const defaultEdgeColor = isLight ? '#666666' : '#848484';
                    
                    edges.update({
                        id: edgeId,
                        color: { color: defaultEdgeColor, highlight: '#00d4ff' },
                        width: edge.type === 'chain' ? 4 : 2
                    });
                }
            });
            highlightedFlowPaths.clear();
            
            // Restore node sizes
            nodes.forEach(node => {
                const size = getNodeSize(node);
                nodes.update({
                    id: node.id,
                    size: size
                });
            });
            
            flowPaths = [];
            
            // Hide notification
            hideFlowPathNotification();
        }
        
        // Analytics help functions
        function toggleAnalyticsHelp() {
            const helpDiv = document.getElementById('analytics-help');
            const toggleBtn = document.getElementById('analytics-help-toggle');
            if (helpDiv.style.display === 'none') {
                helpDiv.style.display = 'block';
                toggleBtn.textContent = '‚àí';
                toggleBtn.title = 'Hide Help';
            } else {
                helpDiv.style.display = 'none';
                toggleBtn.textContent = '?';
                toggleBtn.title = 'Show/Hide Help';
            }
        }
        
        function showColorSchemeHelp() {
            const selector = document.getElementById('color-scheme-selector');
            const descriptionDiv = document.getElementById('color-scheme-description');
            const scheme = selector.value;
            
            const descriptions = {
                'heatmap': 'Heatmap: Red (low activity) ‚Üí Yellow (medium) ‚Üí Green (high activity). Blocks show transaction count, transactions show input/output count, addresses show UTxO count.',
                'activity': 'Activity: Blue (low activity) ‚Üí Purple (medium) ‚Üí Red (high activity). Same metrics as heatmap but with different color progression.',
                'grayscale': 'Grayscale: Black (low activity) ‚Üí Gray ‚Üí White (high activity). Useful for printing or colorblind accessibility.'
            };
            
            descriptionDiv.textContent = descriptions[scheme] || descriptions['heatmap'];
            descriptionDiv.style.display = 'block';
        }
        
        function hideColorSchemeHelp() {
            // Keep description visible for a moment, then hide
            setTimeout(() => {
                const descriptionDiv = document.getElementById('color-scheme-description');
                if (descriptionDiv && document.activeElement !== document.getElementById('color-scheme-selector')) {
                    descriptionDiv.style.display = 'none';
                }
            }, 200);
        }
        
        // Make functions globally accessible
        window.changeColorScheme = changeColorScheme;
        window.recalculateAnalytics = recalculateAnalytics;
        window.toggleAnalyticsHelp = toggleAnalyticsHelp;
        window.showColorSchemeHelp = showColorSchemeHelp;
        window.hideColorSchemeHelp = hideColorSchemeHelp;
        window.toggleAnomalyHighlighting = toggleAnomalyHighlighting;
        
        // Initialize - wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                loadGraph();
                connectSSE();
                checkStatus();
                setInterval(checkStatus, 10000); // Check status every 10 seconds
            });
        } else {
            // DOM is already ready
            loadGraph();
            connectSSE();
            checkStatus();
            setInterval(checkStatus, 10000); // Check status every 10 seconds
        }
    </script>
</body>
</html>

